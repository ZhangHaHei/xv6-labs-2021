1. a0-7 a2
2. 没有调用f函数对应的汇编源码，因为g(x)被内联到f(x)中，然后f(x)又被进一步内联到main0中。
3. auipc(Add Upper Immediate to PC)得到pc的值0x30存储在ra寄存器，jalr (jump and link register)指令跳转到ra寄存器的值并加上偏移量1536(即0x600),所以printf的地址是0x630
4. 第1行代码：对比指令格式，这行代码将0x0左移12位（还是0x0)加到pc(当前为0x30)并存入ra中，即ra中保存的是0x30第2行代码：这对比jl的标准格十右听不同，可能是此两处使用寄存器相同时，
   汇编中可以省略rd部分。ra中保存的是0x30,加上0为0x630,即printf的地址，执行此行代码后，将跳转到printf函数执行，并将当前pc+4=0X34+0X4=0X38保存到ra中，供之后返回使用。
5. 57616=0xE110,0x00646c72小端存储为72-6c-64-00,对照ASC码表：72：r 6c:l 64:d 00:充当字符串结尾标识 因此输出为：HE110 World
   若为大端存储，i应改为0x726c6400,不需改变57616
6. 原本需要两个参数，却只传入了一个，因此y=后面打印的结果取决于之前a2中保存的数据。